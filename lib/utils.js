import { keccak256 } from "@ethersproject/solidity";
import { IncrementalMerkleTree } from "@zk-kit/incremental-merkle-tree";
import { ZqField } from "ffjavascript";
import poseidon from 'poseidon-lite';
/*
  This is the "Baby Jubjub" curve described here:
  https://iden3-docs.readthedocs.io/en/latest/_downloads/33717d75ab84e11313cc0d8a090b636f/Baby-Jubjub.pdf
*/
export const SNARK_FIELD_SIZE = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
// Creates the finite field
export const Fq = new ZqField(SNARK_FIELD_SIZE);
/**
 * Generates an External Nullifier for use with RLN.
 * @param plaintext String. //TODO: better description
 * @returns External Nullifier in a string.
 */
export function genExternalNullifier(plaintext) {
    const hashed = keccak256(["string"], [plaintext]);
    const hexStr = `0x${hashed.slice(8)}`;
    const len = 32 * 2;
    const h = hexStr.slice(2, len + 2);
    return `0x${h.padStart(len, "0")}`;
}
/**
 * Creates a Merkle Tree.
 * @param depth The depth of the tree.
 * @param zeroValue The zero value of the tree.
 * @param leaves The list of the leaves of the tree.
 * @returns The Merkle tree.
 */
export async function generateMerkleTree(depth, zeroValue, leaves) {
    const tree = new IncrementalMerkleTree(poseidon, depth, zeroValue, 2);
    for (const leaf of leaves) {
        tree.insert(BigInt(leaf));
    }
    return tree;
}
/**
 * Creates a Merkle Proof.
 * @param depth The depth of the tree.
 * @param zeroValue The zero value of the tree.
 * @param leaves The list of the leaves of the tree.
 * @param leaf The leaf for which Merkle proof should be created.
 * @returns The Merkle proof.
 */
export async function generateMerkleProof(depth, zeroValue, leaves, leaf) {
    if (leaf === zeroValue)
        throw new Error("Can't generate a proof for a zero leaf");
    const tree = await generateMerkleTree(depth, zeroValue, leaves);
    const leafIndex = tree.leaves.indexOf(BigInt(leaf));
    if (leafIndex === -1) {
        throw new Error("The leaf does not exist");
    }
    const merkleProof = tree.createProof(leafIndex);
    merkleProof.siblings = merkleProof.siblings.map((s) => s[0]);
    return merkleProof;
}
export async function getSecretHash(identity) {
    const nullifier = identity.getNullifier();
    const trapdoor = identity.getTrapdoor();
    return await poseidon([nullifier, trapdoor]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFBO0FBRW5ELE9BQU8sRUFBRSxxQkFBcUIsRUFBZSxNQUFNLGlDQUFpQyxDQUFBO0FBQ3BGLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUE7QUFFdEMsT0FBTyxRQUFRLE1BQU0sZUFBZSxDQUFBO0FBRXBDOzs7RUFHRTtBQUNGLE1BQU0sQ0FBQyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQywrRUFBK0UsQ0FBQyxDQUFBO0FBRXZILDJCQUEyQjtBQUMzQixNQUFNLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtBQUcvQzs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUFDLFNBQWlCO0lBQ3BELE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQTtJQUNqRCxNQUFNLE1BQU0sR0FBRyxLQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtJQUNyQyxNQUFNLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0lBQ2xCLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQTtJQUVsQyxPQUFPLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQTtBQUNwQyxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxDQUFDLEtBQUssVUFBVSxrQkFBa0IsQ0FBQyxLQUFhLEVBQUUsU0FBb0IsRUFBRSxNQUFtQjtJQUMvRixNQUFNLElBQUksR0FBRyxJQUFJLHFCQUFxQixDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFBO0lBRXJFLEtBQUssTUFBTSxJQUFJLElBQUksTUFBTSxFQUFFO1FBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUE7S0FDMUI7SUFFRCxPQUFPLElBQUksQ0FBQTtBQUNiLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxDQUFDLEtBQUssVUFBVSxtQkFBbUIsQ0FDdkMsS0FBYSxFQUNiLFNBQW9CLEVBQ3BCLE1BQW1CLEVBQ25CLElBQWU7SUFFZixJQUFJLElBQUksS0FBSyxTQUFTO1FBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFBO0lBRWpGLE1BQU0sSUFBSSxHQUFHLE1BQU0sa0JBQWtCLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQTtJQUUvRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtJQUVuRCxJQUFJLFNBQVMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUE7S0FDM0M7SUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFBO0lBRS9DLFdBQVcsQ0FBQyxRQUFRLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBRTVELE9BQU8sV0FBVyxDQUFBO0FBQ3BCLENBQUM7QUFFRCxNQUFNLENBQUMsS0FBSyxVQUFVLGFBQWEsQ0FBQyxRQUFrQjtJQUNwRCxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUE7SUFDekMsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFBO0lBQ3ZDLE9BQU8sTUFBTSxRQUFRLENBQUMsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQTtBQUM5QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NvbGlkaXR5XCJcbmltcG9ydCB0eXBlIHsgSWRlbnRpdHkgfSBmcm9tICdAc2VtYXBob3JlLXByb3RvY29sL2lkZW50aXR5J1xuaW1wb3J0IHsgSW5jcmVtZW50YWxNZXJrbGVUcmVlLCBNZXJrbGVQcm9vZiB9IGZyb20gXCJAemsta2l0L2luY3JlbWVudGFsLW1lcmtsZS10cmVlXCJcbmltcG9ydCB7IFpxRmllbGQgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCJcbmltcG9ydCB7IFN0ckJpZ0ludCB9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCBwb3NlaWRvbiBmcm9tICdwb3NlaWRvbi1saXRlJ1xuXG4vKlxuICBUaGlzIGlzIHRoZSBcIkJhYnkgSnVianViXCIgY3VydmUgZGVzY3JpYmVkIGhlcmU6XG4gIGh0dHBzOi8vaWRlbjMtZG9jcy5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvX2Rvd25sb2Fkcy8zMzcxN2Q3NWFiODRlMTEzMTNjYzBkOGEwOTBiNjM2Zi9CYWJ5LUp1Ymp1Yi5wZGZcbiovXG5leHBvcnQgY29uc3QgU05BUktfRklFTERfU0laRSA9IEJpZ0ludChcIjIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4NTQ4MzY0NDAwNDE2MDM0MzQzNjk4MjA0MTg2NTc1ODA4NDk1NjE3XCIpXG5cbi8vIENyZWF0ZXMgdGhlIGZpbml0ZSBmaWVsZFxuZXhwb3J0IGNvbnN0IEZxID0gbmV3IFpxRmllbGQoU05BUktfRklFTERfU0laRSlcblxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBFeHRlcm5hbCBOdWxsaWZpZXIgZm9yIHVzZSB3aXRoIFJMTi5cbiAqIEBwYXJhbSBwbGFpbnRleHQgU3RyaW5nLiAvL1RPRE86IGJldHRlciBkZXNjcmlwdGlvblxuICogQHJldHVybnMgRXh0ZXJuYWwgTnVsbGlmaWVyIGluIGEgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuRXh0ZXJuYWxOdWxsaWZpZXIocGxhaW50ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBoYXNoZWQgPSBrZWNjYWsyNTYoW1wic3RyaW5nXCJdLCBbcGxhaW50ZXh0XSlcbiAgY29uc3QgaGV4U3RyID0gYDB4JHtoYXNoZWQuc2xpY2UoOCl9YFxuICBjb25zdCBsZW4gPSAzMiAqIDJcbiAgY29uc3QgaCA9IGhleFN0ci5zbGljZSgyLCBsZW4gKyAyKVxuXG4gIHJldHVybiBgMHgke2gucGFkU3RhcnQobGVuLCBcIjBcIil9YFxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBNZXJrbGUgVHJlZS5cbiAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIHRyZWUuXG4gKiBAcGFyYW0gemVyb1ZhbHVlIFRoZSB6ZXJvIHZhbHVlIG9mIHRoZSB0cmVlLlxuICogQHBhcmFtIGxlYXZlcyBUaGUgbGlzdCBvZiB0aGUgbGVhdmVzIG9mIHRoZSB0cmVlLlxuICogQHJldHVybnMgVGhlIE1lcmtsZSB0cmVlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVNZXJrbGVUcmVlKGRlcHRoOiBudW1iZXIsIHplcm9WYWx1ZTogU3RyQmlnSW50LCBsZWF2ZXM6IFN0ckJpZ0ludFtdKTogUHJvbWlzZTxJbmNyZW1lbnRhbE1lcmtsZVRyZWU+IHtcbiAgY29uc3QgdHJlZSA9IG5ldyBJbmNyZW1lbnRhbE1lcmtsZVRyZWUocG9zZWlkb24sIGRlcHRoLCB6ZXJvVmFsdWUsIDIpXG5cbiAgZm9yIChjb25zdCBsZWFmIG9mIGxlYXZlcykge1xuICAgIHRyZWUuaW5zZXJ0KEJpZ0ludChsZWFmKSlcbiAgfVxuXG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE1lcmtsZSBQcm9vZi5cbiAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIHRyZWUuXG4gKiBAcGFyYW0gemVyb1ZhbHVlIFRoZSB6ZXJvIHZhbHVlIG9mIHRoZSB0cmVlLlxuICogQHBhcmFtIGxlYXZlcyBUaGUgbGlzdCBvZiB0aGUgbGVhdmVzIG9mIHRoZSB0cmVlLlxuICogQHBhcmFtIGxlYWYgVGhlIGxlYWYgZm9yIHdoaWNoIE1lcmtsZSBwcm9vZiBzaG91bGQgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIFRoZSBNZXJrbGUgcHJvb2YuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU1lcmtsZVByb29mKFxuICBkZXB0aDogbnVtYmVyLFxuICB6ZXJvVmFsdWU6IFN0ckJpZ0ludCxcbiAgbGVhdmVzOiBTdHJCaWdJbnRbXSxcbiAgbGVhZjogU3RyQmlnSW50XG4pOiBQcm9taXNlPE1lcmtsZVByb29mPiB7XG4gIGlmIChsZWFmID09PSB6ZXJvVmFsdWUpIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGdlbmVyYXRlIGEgcHJvb2YgZm9yIGEgemVybyBsZWFmXCIpXG5cbiAgY29uc3QgdHJlZSA9IGF3YWl0IGdlbmVyYXRlTWVya2xlVHJlZShkZXB0aCwgemVyb1ZhbHVlLCBsZWF2ZXMpXG5cbiAgY29uc3QgbGVhZkluZGV4ID0gdHJlZS5sZWF2ZXMuaW5kZXhPZihCaWdJbnQobGVhZikpXG5cbiAgaWYgKGxlYWZJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGVhZiBkb2VzIG5vdCBleGlzdFwiKVxuICB9XG5cbiAgY29uc3QgbWVya2xlUHJvb2YgPSB0cmVlLmNyZWF0ZVByb29mKGxlYWZJbmRleClcblxuICBtZXJrbGVQcm9vZi5zaWJsaW5ncyA9IG1lcmtsZVByb29mLnNpYmxpbmdzLm1hcCgocykgPT4gc1swXSlcblxuICByZXR1cm4gbWVya2xlUHJvb2Zcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNlY3JldEhhc2goaWRlbnRpdHk6IElkZW50aXR5KTogUHJvbWlzZTxiaWdpbnQ+IHtcbiAgY29uc3QgbnVsbGlmaWVyID0gaWRlbnRpdHkuZ2V0TnVsbGlmaWVyKClcbiAgY29uc3QgdHJhcGRvb3IgPSBpZGVudGl0eS5nZXRUcmFwZG9vcigpXG4gIHJldHVybiBhd2FpdCBwb3NlaWRvbihbbnVsbGlmaWVyLCB0cmFwZG9vcl0pXG59Il19