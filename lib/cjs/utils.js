"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMerkleProof = exports.generateMerkleTree = exports.genExternalNullifier = exports.Fq = exports.SNARK_FIELD_SIZE = exports.buildPoseidon = void 0;
const solidity_1 = require("@ethersproject/solidity");
const incremental_merkle_tree_1 = require("@zk-kit/incremental-merkle-tree");
const circomlibjs_1 = require("circomlibjs");
const ffjavascript_1 = require("ffjavascript");
/**
 *  Wrapper for Poseidon hash function to parse return value format from Uint8Array to BigInt
 */
async function buildPoseidon() {
    const poseidon = await (0, circomlibjs_1.buildPoseidonOpt)();
    return (input) => {
        const result = poseidon(input);
        return BigInt(poseidon.F.toString(result));
    };
}
exports.buildPoseidon = buildPoseidon;
/*
  This is the "Baby Jubjub" curve described here:
  https://iden3-docs.readthedocs.io/en/latest/_downloads/33717d75ab84e11313cc0d8a090b636f/Baby-Jubjub.pdf
*/
exports.SNARK_FIELD_SIZE = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
// Creates the finite field
exports.Fq = new ffjavascript_1.ZqField(exports.SNARK_FIELD_SIZE);
/**
 * Generates an External Nullifier for use with RLN.
 * @param plaintext String. //TODO: better description
 * @returns External Nullifier in a string.
 */
function genExternalNullifier(plaintext) {
    const hashed = (0, solidity_1.keccak256)(["string"], [plaintext]);
    const hexStr = `0x${hashed.slice(8)}`;
    const len = 32 * 2;
    const h = hexStr.slice(2, len + 2);
    return `0x${h.padStart(len, "0")}`;
}
exports.genExternalNullifier = genExternalNullifier;
/**
 * Creates a Merkle Tree.
 * @param depth The depth of the tree.
 * @param zeroValue The zero value of the tree.
 * @param leaves The list of the leaves of the tree.
 * @returns The Merkle tree.
 */
async function generateMerkleTree(depth, zeroValue, leaves) {
    const poseidon = await buildPoseidon();
    const tree = new incremental_merkle_tree_1.IncrementalMerkleTree(poseidon, depth, zeroValue, 2);
    for (const leaf of leaves) {
        tree.insert(BigInt(leaf));
    }
    return tree;
}
exports.generateMerkleTree = generateMerkleTree;
/**
 * Creates a Merkle Proof.
 * @param depth The depth of the tree.
 * @param zeroValue The zero value of the tree.
 * @param leaves The list of the leaves of the tree.
 * @param leaf The leaf for which Merkle proof should be created.
 * @returns The Merkle proof.
 */
async function generateMerkleProof(depth, zeroValue, leaves, leaf) {
    if (leaf === zeroValue)
        throw new Error("Can't generate a proof for a zero leaf");
    const tree = await generateMerkleTree(depth, zeroValue, leaves);
    const leafIndex = tree.leaves.indexOf(BigInt(leaf));
    if (leafIndex === -1) {
        throw new Error("The leaf does not exist");
    }
    const merkleProof = tree.createProof(leafIndex);
    merkleProof.siblings = merkleProof.siblings.map((s) => s[0]);
    return merkleProof;
}
exports.generateMerkleProof = generateMerkleProof;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0RBQW1EO0FBQ25ELDZFQUFvRjtBQUNwRiw2Q0FBOEM7QUFDOUMsK0NBQXNDO0FBR3RDOztHQUVHO0FBQ0ksS0FBSyxVQUFVLGFBQWE7SUFDakMsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFBLDhCQUFnQixHQUFFLENBQUE7SUFFekMsT0FBTyxDQUFDLEtBQVUsRUFBVSxFQUFFO1FBQzVCLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtRQUM5QixPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFBO0lBQzVDLENBQUMsQ0FBQTtBQUNILENBQUM7QUFQRCxzQ0FPQztBQUVEOzs7RUFHRTtBQUNXLFFBQUEsZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLCtFQUErRSxDQUFDLENBQUE7QUFFdkgsMkJBQTJCO0FBQ2QsUUFBQSxFQUFFLEdBQUcsSUFBSSxzQkFBTyxDQUFDLHdCQUFnQixDQUFDLENBQUE7QUFHL0M7Ozs7R0FJRztBQUNILFNBQWdCLG9CQUFvQixDQUFDLFNBQWlCO0lBQ3BELE1BQU0sTUFBTSxHQUFHLElBQUEsb0JBQVMsRUFBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQTtJQUNqRCxNQUFNLE1BQU0sR0FBRyxLQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtJQUNyQyxNQUFNLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0lBQ2xCLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQTtJQUVsQyxPQUFPLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQTtBQUNwQyxDQUFDO0FBUEQsb0RBT0M7QUFFRDs7Ozs7O0dBTUc7QUFDSSxLQUFLLFVBQVUsa0JBQWtCLENBQUMsS0FBYSxFQUFFLFNBQW9CLEVBQUUsTUFBbUI7SUFDL0YsTUFBTSxRQUFRLEdBQUcsTUFBTSxhQUFhLEVBQUUsQ0FBQTtJQUV0QyxNQUFNLElBQUksR0FBRyxJQUFJLCtDQUFxQixDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFBO0lBRXJFLEtBQUssTUFBTSxJQUFJLElBQUksTUFBTSxFQUFFO1FBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUE7S0FDMUI7SUFFRCxPQUFPLElBQUksQ0FBQTtBQUNiLENBQUM7QUFWRCxnREFVQztBQUVEOzs7Ozs7O0dBT0c7QUFDSSxLQUFLLFVBQVUsbUJBQW1CLENBQ3ZDLEtBQWEsRUFDYixTQUFvQixFQUNwQixNQUFtQixFQUNuQixJQUFlO0lBRWYsSUFBSSxJQUFJLEtBQUssU0FBUztRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQTtJQUVqRixNQUFNLElBQUksR0FBRyxNQUFNLGtCQUFrQixDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUE7SUFFL0QsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUE7SUFFbkQsSUFBSSxTQUFTLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFBO0tBQzNDO0lBRUQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQTtJQUUvQyxXQUFXLENBQUMsUUFBUSxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUU1RCxPQUFPLFdBQVcsQ0FBQTtBQUNwQixDQUFDO0FBckJELGtEQXFCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zb2xpZGl0eVwiXG5pbXBvcnQgeyBJbmNyZW1lbnRhbE1lcmtsZVRyZWUsIE1lcmtsZVByb29mIH0gZnJvbSBcIkB6ay1raXQvaW5jcmVtZW50YWwtbWVya2xlLXRyZWVcIlxuaW1wb3J0IHsgYnVpbGRQb3NlaWRvbk9wdCB9IGZyb20gXCJjaXJjb21saWJqc1wiXG5pbXBvcnQgeyBacUZpZWxkIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiXG5pbXBvcnQgeyBTdHJCaWdJbnQgfSBmcm9tIFwiLi90eXBlc1wiXG5cbi8qKlxuICogIFdyYXBwZXIgZm9yIFBvc2VpZG9uIGhhc2ggZnVuY3Rpb24gdG8gcGFyc2UgcmV0dXJuIHZhbHVlIGZvcm1hdCBmcm9tIFVpbnQ4QXJyYXkgdG8gQmlnSW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZFBvc2VpZG9uKCkge1xuICBjb25zdCBwb3NlaWRvbiA9IGF3YWl0IGJ1aWxkUG9zZWlkb25PcHQoKVxuXG4gIHJldHVybiAoaW5wdXQ6IGFueSk6IGJpZ2ludCA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gcG9zZWlkb24oaW5wdXQpXG4gICAgcmV0dXJuIEJpZ0ludChwb3NlaWRvbi5GLnRvU3RyaW5nKHJlc3VsdCkpXG4gIH1cbn1cblxuLypcbiAgVGhpcyBpcyB0aGUgXCJCYWJ5IEp1Ymp1YlwiIGN1cnZlIGRlc2NyaWJlZCBoZXJlOlxuICBodHRwczovL2lkZW4zLWRvY3MucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L19kb3dubG9hZHMvMzM3MTdkNzVhYjg0ZTExMzEzY2MwZDhhMDkwYjYzNmYvQmFieS1KdWJqdWIucGRmXG4qL1xuZXhwb3J0IGNvbnN0IFNOQVJLX0ZJRUxEX1NJWkUgPSBCaWdJbnQoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODU0ODM2NDQwMDQxNjAzNDM0MzY5ODIwNDE4NjU3NTgwODQ5NTYxN1wiKVxuXG4vLyBDcmVhdGVzIHRoZSBmaW5pdGUgZmllbGRcbmV4cG9ydCBjb25zdCBGcSA9IG5ldyBacUZpZWxkKFNOQVJLX0ZJRUxEX1NJWkUpXG5cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gRXh0ZXJuYWwgTnVsbGlmaWVyIGZvciB1c2Ugd2l0aCBSTE4uXG4gKiBAcGFyYW0gcGxhaW50ZXh0IFN0cmluZy4gLy9UT0RPOiBiZXR0ZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIEV4dGVybmFsIE51bGxpZmllciBpbiBhIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbkV4dGVybmFsTnVsbGlmaWVyKHBsYWludGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgaGFzaGVkID0ga2VjY2FrMjU2KFtcInN0cmluZ1wiXSwgW3BsYWludGV4dF0pXG4gIGNvbnN0IGhleFN0ciA9IGAweCR7aGFzaGVkLnNsaWNlKDgpfWBcbiAgY29uc3QgbGVuID0gMzIgKiAyXG4gIGNvbnN0IGggPSBoZXhTdHIuc2xpY2UoMiwgbGVuICsgMilcblxuICByZXR1cm4gYDB4JHtoLnBhZFN0YXJ0KGxlbiwgXCIwXCIpfWBcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTWVya2xlIFRyZWUuXG4gKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSB0cmVlLlxuICogQHBhcmFtIHplcm9WYWx1ZSBUaGUgemVybyB2YWx1ZSBvZiB0aGUgdHJlZS5cbiAqIEBwYXJhbSBsZWF2ZXMgVGhlIGxpc3Qgb2YgdGhlIGxlYXZlcyBvZiB0aGUgdHJlZS5cbiAqIEByZXR1cm5zIFRoZSBNZXJrbGUgdHJlZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlTWVya2xlVHJlZShkZXB0aDogbnVtYmVyLCB6ZXJvVmFsdWU6IFN0ckJpZ0ludCwgbGVhdmVzOiBTdHJCaWdJbnRbXSk6IFByb21pc2U8SW5jcmVtZW50YWxNZXJrbGVUcmVlPiB7XG4gIGNvbnN0IHBvc2VpZG9uID0gYXdhaXQgYnVpbGRQb3NlaWRvbigpXG5cbiAgY29uc3QgdHJlZSA9IG5ldyBJbmNyZW1lbnRhbE1lcmtsZVRyZWUocG9zZWlkb24sIGRlcHRoLCB6ZXJvVmFsdWUsIDIpXG5cbiAgZm9yIChjb25zdCBsZWFmIG9mIGxlYXZlcykge1xuICAgIHRyZWUuaW5zZXJ0KEJpZ0ludChsZWFmKSlcbiAgfVxuXG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE1lcmtsZSBQcm9vZi5cbiAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIHRyZWUuXG4gKiBAcGFyYW0gemVyb1ZhbHVlIFRoZSB6ZXJvIHZhbHVlIG9mIHRoZSB0cmVlLlxuICogQHBhcmFtIGxlYXZlcyBUaGUgbGlzdCBvZiB0aGUgbGVhdmVzIG9mIHRoZSB0cmVlLlxuICogQHBhcmFtIGxlYWYgVGhlIGxlYWYgZm9yIHdoaWNoIE1lcmtsZSBwcm9vZiBzaG91bGQgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIFRoZSBNZXJrbGUgcHJvb2YuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU1lcmtsZVByb29mKFxuICBkZXB0aDogbnVtYmVyLFxuICB6ZXJvVmFsdWU6IFN0ckJpZ0ludCxcbiAgbGVhdmVzOiBTdHJCaWdJbnRbXSxcbiAgbGVhZjogU3RyQmlnSW50XG4pOiBQcm9taXNlPE1lcmtsZVByb29mPiB7XG4gIGlmIChsZWFmID09PSB6ZXJvVmFsdWUpIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGdlbmVyYXRlIGEgcHJvb2YgZm9yIGEgemVybyBsZWFmXCIpXG5cbiAgY29uc3QgdHJlZSA9IGF3YWl0IGdlbmVyYXRlTWVya2xlVHJlZShkZXB0aCwgemVyb1ZhbHVlLCBsZWF2ZXMpXG5cbiAgY29uc3QgbGVhZkluZGV4ID0gdHJlZS5sZWF2ZXMuaW5kZXhPZihCaWdJbnQobGVhZikpXG5cbiAgaWYgKGxlYWZJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGVhZiBkb2VzIG5vdCBleGlzdFwiKVxuICB9XG5cbiAgY29uc3QgbWVya2xlUHJvb2YgPSB0cmVlLmNyZWF0ZVByb29mKGxlYWZJbmRleClcblxuICBtZXJrbGVQcm9vZi5zaWJsaW5ncyA9IG1lcmtsZVByb29mLnNpYmxpbmdzLm1hcCgocykgPT4gc1swXSlcblxuICByZXR1cm4gbWVya2xlUHJvb2Zcbn1cbiJdfQ==