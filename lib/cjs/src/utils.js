"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSecretHash = exports.generateMerkleProof = exports.generateMerkleTree = exports.genExternalNullifier = exports.Fq = exports.SNARK_FIELD_SIZE = void 0;
const solidity_1 = require("@ethersproject/solidity");
const incremental_merkle_tree_1 = require("@zk-kit/incremental-merkle-tree");
const ffjavascript_1 = require("ffjavascript");
const poseidon_lite_1 = __importDefault(require("poseidon-lite"));
/*
  This is the "Baby Jubjub" curve described here:
  https://iden3-docs.readthedocs.io/en/latest/_downloads/33717d75ab84e11313cc0d8a090b636f/Baby-Jubjub.pdf
*/
exports.SNARK_FIELD_SIZE = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
// Creates the finite field
exports.Fq = new ffjavascript_1.ZqField(exports.SNARK_FIELD_SIZE);
/**
 * Generates an External Nullifier for use with RLN.
 * @param plaintext String. //TODO: better description
 * @returns External Nullifier in a string.
 */
function genExternalNullifier(plaintext) {
    const hashed = (0, solidity_1.keccak256)(["string"], [plaintext]);
    const hexStr = `0x${hashed.slice(8)}`;
    const len = 32 * 2;
    const h = hexStr.slice(2, len + 2);
    return `0x${h.padStart(len, "0")}`;
}
exports.genExternalNullifier = genExternalNullifier;
/**
 * Creates a Merkle Tree.
 * @param depth The depth of the tree.
 * @param zeroValue The zero value of the tree.
 * @param leaves The list of the leaves of the tree.
 * @returns The Merkle tree.
 */
async function generateMerkleTree(depth, zeroValue, leaves) {
    const tree = new incremental_merkle_tree_1.IncrementalMerkleTree(poseidon_lite_1.default, depth, zeroValue, 2);
    for (const leaf of leaves) {
        tree.insert(BigInt(leaf));
    }
    return tree;
}
exports.generateMerkleTree = generateMerkleTree;
/**
 * Creates a Merkle Proof.
 * @param depth The depth of the tree.
 * @param zeroValue The zero value of the tree.
 * @param leaves The list of the leaves of the tree.
 * @param leaf The leaf for which Merkle proof should be created.
 * @returns The Merkle proof.
 */
async function generateMerkleProof(depth, zeroValue, leaves, leaf) {
    if (leaf === zeroValue)
        throw new Error("Can't generate a proof for a zero leaf");
    const tree = await generateMerkleTree(depth, zeroValue, leaves);
    const leafIndex = tree.leaves.indexOf(BigInt(leaf));
    if (leafIndex === -1) {
        throw new Error("The leaf does not exist");
    }
    const merkleProof = tree.createProof(leafIndex);
    merkleProof.siblings = merkleProof.siblings.map((s) => s[0]);
    return merkleProof;
}
exports.generateMerkleProof = generateMerkleProof;
async function getSecretHash(identity) {
    const nullifier = identity.getNullifier();
    const trapdoor = identity.getTrapdoor();
    return await (0, poseidon_lite_1.default)([nullifier, trapdoor]);
}
exports.getSecretHash = getSecretHash;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsc0RBQW1EO0FBRW5ELDZFQUFvRjtBQUNwRiwrQ0FBc0M7QUFFdEMsa0VBQW9DO0FBRXBDOzs7RUFHRTtBQUNXLFFBQUEsZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLCtFQUErRSxDQUFDLENBQUE7QUFFdkgsMkJBQTJCO0FBQ2QsUUFBQSxFQUFFLEdBQUcsSUFBSSxzQkFBTyxDQUFDLHdCQUFnQixDQUFDLENBQUE7QUFHL0M7Ozs7R0FJRztBQUNILFNBQWdCLG9CQUFvQixDQUFDLFNBQWlCO0lBQ3BELE1BQU0sTUFBTSxHQUFHLElBQUEsb0JBQVMsRUFBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQTtJQUNqRCxNQUFNLE1BQU0sR0FBRyxLQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtJQUNyQyxNQUFNLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0lBQ2xCLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQTtJQUVsQyxPQUFPLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQTtBQUNwQyxDQUFDO0FBUEQsb0RBT0M7QUFFRDs7Ozs7O0dBTUc7QUFDSSxLQUFLLFVBQVUsa0JBQWtCLENBQUMsS0FBYSxFQUFFLFNBQW9CLEVBQUUsTUFBbUI7SUFDL0YsTUFBTSxJQUFJLEdBQUcsSUFBSSwrQ0FBcUIsQ0FBQyx1QkFBUSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFFckUsS0FBSyxNQUFNLElBQUksSUFBSSxNQUFNLEVBQUU7UUFDekIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtLQUMxQjtJQUVELE9BQU8sSUFBSSxDQUFBO0FBQ2IsQ0FBQztBQVJELGdEQVFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNJLEtBQUssVUFBVSxtQkFBbUIsQ0FDdkMsS0FBYSxFQUNiLFNBQW9CLEVBQ3BCLE1BQW1CLEVBQ25CLElBQWU7SUFFZixJQUFJLElBQUksS0FBSyxTQUFTO1FBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFBO0lBRWpGLE1BQU0sSUFBSSxHQUFHLE1BQU0sa0JBQWtCLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQTtJQUUvRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtJQUVuRCxJQUFJLFNBQVMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUE7S0FDM0M7SUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFBO0lBRS9DLFdBQVcsQ0FBQyxRQUFRLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBRTVELE9BQU8sV0FBVyxDQUFBO0FBQ3BCLENBQUM7QUFyQkQsa0RBcUJDO0FBRU0sS0FBSyxVQUFVLGFBQWEsQ0FBQyxRQUFrQjtJQUNwRCxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUE7SUFDekMsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFBO0lBQ3ZDLE9BQU8sTUFBTSxJQUFBLHVCQUFRLEVBQUMsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQTtBQUM5QyxDQUFDO0FBSkQsc0NBSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc29saWRpdHlcIlxuaW1wb3J0IHR5cGUgeyBJZGVudGl0eSB9IGZyb20gJ0BzZW1hcGhvcmUtcHJvdG9jb2wvaWRlbnRpdHknXG5pbXBvcnQgeyBJbmNyZW1lbnRhbE1lcmtsZVRyZWUsIE1lcmtsZVByb29mIH0gZnJvbSBcIkB6ay1raXQvaW5jcmVtZW50YWwtbWVya2xlLXRyZWVcIlxuaW1wb3J0IHsgWnFGaWVsZCB9IGZyb20gXCJmZmphdmFzY3JpcHRcIlxuaW1wb3J0IHsgU3RyQmlnSW50IH0gZnJvbSBcIi4vdHlwZXNcIlxuaW1wb3J0IHBvc2VpZG9uIGZyb20gJ3Bvc2VpZG9uLWxpdGUnXG5cbi8qXG4gIFRoaXMgaXMgdGhlIFwiQmFieSBKdWJqdWJcIiBjdXJ2ZSBkZXNjcmliZWQgaGVyZTpcbiAgaHR0cHM6Ly9pZGVuMy1kb2NzLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC9fZG93bmxvYWRzLzMzNzE3ZDc1YWI4NGUxMTMxM2NjMGQ4YTA5MGI2MzZmL0JhYnktSnVianViLnBkZlxuKi9cbmV4cG9ydCBjb25zdCBTTkFSS19GSUVMRF9TSVpFID0gQmlnSW50KFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIilcblxuLy8gQ3JlYXRlcyB0aGUgZmluaXRlIGZpZWxkXG5leHBvcnQgY29uc3QgRnEgPSBuZXcgWnFGaWVsZChTTkFSS19GSUVMRF9TSVpFKVxuXG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIEV4dGVybmFsIE51bGxpZmllciBmb3IgdXNlIHdpdGggUkxOLlxuICogQHBhcmFtIHBsYWludGV4dCBTdHJpbmcuIC8vVE9ETzogYmV0dGVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyBFeHRlcm5hbCBOdWxsaWZpZXIgaW4gYSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5FeHRlcm5hbE51bGxpZmllcihwbGFpbnRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGhhc2hlZCA9IGtlY2NhazI1NihbXCJzdHJpbmdcIl0sIFtwbGFpbnRleHRdKVxuICBjb25zdCBoZXhTdHIgPSBgMHgke2hhc2hlZC5zbGljZSg4KX1gXG4gIGNvbnN0IGxlbiA9IDMyICogMlxuICBjb25zdCBoID0gaGV4U3RyLnNsaWNlKDIsIGxlbiArIDIpXG5cbiAgcmV0dXJuIGAweCR7aC5wYWRTdGFydChsZW4sIFwiMFwiKX1gXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE1lcmtsZSBUcmVlLlxuICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgdHJlZS5cbiAqIEBwYXJhbSB6ZXJvVmFsdWUgVGhlIHplcm8gdmFsdWUgb2YgdGhlIHRyZWUuXG4gKiBAcGFyYW0gbGVhdmVzIFRoZSBsaXN0IG9mIHRoZSBsZWF2ZXMgb2YgdGhlIHRyZWUuXG4gKiBAcmV0dXJucyBUaGUgTWVya2xlIHRyZWUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU1lcmtsZVRyZWUoZGVwdGg6IG51bWJlciwgemVyb1ZhbHVlOiBTdHJCaWdJbnQsIGxlYXZlczogU3RyQmlnSW50W10pOiBQcm9taXNlPEluY3JlbWVudGFsTWVya2xlVHJlZT4ge1xuICBjb25zdCB0cmVlID0gbmV3IEluY3JlbWVudGFsTWVya2xlVHJlZShwb3NlaWRvbiwgZGVwdGgsIHplcm9WYWx1ZSwgMilcblxuICBmb3IgKGNvbnN0IGxlYWYgb2YgbGVhdmVzKSB7XG4gICAgdHJlZS5pbnNlcnQoQmlnSW50KGxlYWYpKVxuICB9XG5cbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTWVya2xlIFByb29mLlxuICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgdHJlZS5cbiAqIEBwYXJhbSB6ZXJvVmFsdWUgVGhlIHplcm8gdmFsdWUgb2YgdGhlIHRyZWUuXG4gKiBAcGFyYW0gbGVhdmVzIFRoZSBsaXN0IG9mIHRoZSBsZWF2ZXMgb2YgdGhlIHRyZWUuXG4gKiBAcGFyYW0gbGVhZiBUaGUgbGVhZiBmb3Igd2hpY2ggTWVya2xlIHByb29mIHNob3VsZCBiZSBjcmVhdGVkLlxuICogQHJldHVybnMgVGhlIE1lcmtsZSBwcm9vZi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlTWVya2xlUHJvb2YoXG4gIGRlcHRoOiBudW1iZXIsXG4gIHplcm9WYWx1ZTogU3RyQmlnSW50LFxuICBsZWF2ZXM6IFN0ckJpZ0ludFtdLFxuICBsZWFmOiBTdHJCaWdJbnRcbik6IFByb21pc2U8TWVya2xlUHJvb2Y+IHtcbiAgaWYgKGxlYWYgPT09IHplcm9WYWx1ZSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZ2VuZXJhdGUgYSBwcm9vZiBmb3IgYSB6ZXJvIGxlYWZcIilcblxuICBjb25zdCB0cmVlID0gYXdhaXQgZ2VuZXJhdGVNZXJrbGVUcmVlKGRlcHRoLCB6ZXJvVmFsdWUsIGxlYXZlcylcblxuICBjb25zdCBsZWFmSW5kZXggPSB0cmVlLmxlYXZlcy5pbmRleE9mKEJpZ0ludChsZWFmKSlcblxuICBpZiAobGVhZkluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsZWFmIGRvZXMgbm90IGV4aXN0XCIpXG4gIH1cblxuICBjb25zdCBtZXJrbGVQcm9vZiA9IHRyZWUuY3JlYXRlUHJvb2YobGVhZkluZGV4KVxuXG4gIG1lcmtsZVByb29mLnNpYmxpbmdzID0gbWVya2xlUHJvb2Yuc2libGluZ3MubWFwKChzKSA9PiBzWzBdKVxuXG4gIHJldHVybiBtZXJrbGVQcm9vZlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VjcmV0SGFzaChpZGVudGl0eTogSWRlbnRpdHkpOiBQcm9taXNlPGJpZ2ludD4ge1xuICBjb25zdCBudWxsaWZpZXIgPSBpZGVudGl0eS5nZXROdWxsaWZpZXIoKVxuICBjb25zdCB0cmFwZG9vciA9IGlkZW50aXR5LmdldFRyYXBkb29yKClcbiAgcmV0dXJuIGF3YWl0IHBvc2VpZG9uKFtudWxsaWZpZXIsIHRyYXBkb29yXSlcbn0iXX0=